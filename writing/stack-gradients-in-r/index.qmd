---
title: The guide to gradients in R and ggplot2
categories: [tutorial, rstats]
date: 2025-02-24
description: Everything from the basics up to beautiful mesh gradients
image: stack-gradients-in-r.png
resources:
  - stack-gradients-in-r.png
# title-block-banner: true   # manually styled
toc: true
knitr:
  opts_chunk:
    fig-width: 8
    dev: ragg_png
    dev.args:
      bg: transparent
    
---

We can do a lot of fancy stuff in [ggplot2](https://ggplot2.tidyverse.org) with considered use of fonts, sizes and colours. But there are still likely finishing touches that have us reaching for tools like Illustrator every so often.

Until recently, sophisticated gradient backgrounds were one of those things. I often blur photos or use other similar patterns as slide backgrounds to provide a bit (a _bit!_) of visual interest.

But now, it's not hard to do something like that directly in ggplot2!


Gradients and patterns are looking reasonably mature now in R: they've been around [since R 4.1](https://stat.ethz.ch/pipermail/r-announce/2021/000670.html) (released in 2021), and ggplot2 began supporting them in version 3.5.0 (released in early 2024).

That support comes via the `{grid}` package, which ships with R but isn't preloaded. That means you'll either need to call `library(grid)` or prefix a lot of functions with `grid::`.

```{r}
library(ggplot2)
library(grid)
library(systemfonts)
```

I'm also going to define a quick theme to keep these plots looking tidy. It's not really relevant to the post, though, so you can skip it if you'd like!

:::{.callout-note collapse="true"}

## Plot theme

```{r}
theme_blog <- function() {
  theme_dark(base_size = 18, base_family = "Inter") +
  theme(
    text = element_text(colour = "white"),
    axis.text = element_text(colour = "#dddddd"),
    panel.background = element_blank(),
    plot.background = element_blank()
  )
}
```

:::

:::{.column-margin}
Some legacy R graphics devices don't support gradients and patterns at all. Install the [`{ragg}`](https://ragg.r-lib.org) package, which does — it's better for just about everything anyway!

\

I also refer to the [`{systemfonts}`](https://systemfonts.r-lib.org) package above. This is an optional one to make using fonts on your system—or ones you've downloaded—easier.

\
:::


We get two basic gradient tools in `{grid}`: `linearGradient()` and `radialGradient()`. If you've used apps like Photoshop or Illustrator before, that might seem basic — it's no [mesh gradient](https://helpx.adobe.com/au/illustrator/using/meshes.html).

But even this gives us a lot of power. With this new support, you can use a gradient or pattern as the `fill` (but not, as far as I know, the `colour`), for anything outside of an aesthetic.

So that might be a geom's fill:

```{r}
ggplot(mtcars) +
  aes(x = hp) +
  geom_histogram(
    bins = 30,
    colour = "transparent",
    fill = linearGradient(c("red", "orange"))) +
  labs(title = "Gradient on geom") +
  theme_blog()
```

Or it could be a theme option:

```{r}
ggplot(mtcars) +
  aes(x = hp) +
  geom_histogram(
    bins = 30,
    colour = "transparent") +
  labs(title = "Gradient as plot background") +
  theme_blog() +
  theme(
    plot.background = element_rect(
      colour = NA,
      fill = radialGradient(c("gold", "orange", "transparent")))
  )
```

You're probably already realising that with this power comes the potential to make a lot of _ugly charts_—or, perhaps worse, unengaging or misleading ones!

All of the rules that apply to the accessible use of colour in data visualisation apply to gradients and patterns as well. Ensure that plot elements have sufficient contrast to be distinguished, particularly if the meaning of the plot is lost without it.

But with some care, we can add sophisticated effects using these tools.

# Gradient basics

The most basic part of `linearGradient()` and `radialGradient()` is specifying the colours they use. Supply a vector of `colours` the same way you would supply colours elsewhere in R.

If you don't want those colours to be distributed evenly along the gradient, supply a vector of `stops` between 0 and 1. Here we squash the first half of the rainbow, spreading the second half out:

```{r}
squashed_rainbow <- linearGradient(
  c("red", "orange", "yellow", "green", "blue", "darkblue", "purple"),
  c(0, 0.1, 0.2, 0.4, 0.6, 0.8, 1)
)
```

```{r}
#| echo: false
#| fig-height: 1
ggplot() +
  geom_blank()+
  theme_void() +
  theme(
    plot.background = element_rect(
      fill = squashed_rainbow))
```

## Sizing and positioning linear gradients

By default, the two gradients take up the space of all of their parent: `linearGradient()` goes left-to-right and `radialGradient()` goes from the centre out to the (shorter) edge.

To change that, use the positional arguments. For `linearGradient`, those are `x1` and `y1` for the start position, and `x2` and `y2` for the end position. For example, to 

If you simply provide these as numbers, the gradient will interpret these in "Normalised Parent Coordinates", which basically means "percentages of the thing I'm being put on". 0 is the (horizontal or vertical) start of the thing you're painting, and 1 is the end.

Here's a gradient that stretches from the bottom-left corner to the top-right:

```{r}
angled_gradient <- linearGradient(
  c("red", "orange"),
  x1 = 0, y1 = 0, x2 = 1, y2 = 1)
```

One downside of this is that it makes getting a specific angle right difficult, because a wide object and a tall object have things that stretch differently:

```{r}
p1 <- ggplot() +
  geom_blank() +
  theme(
    plot.background = element_rect(
      fill = angled_gradient),
    panel.background = element_blank())
```

```{r}
#| echo: fenced
#| fig-width: 0.5
#| fig-height: 1.5
p1
```

```{r}
#| echo: fenced
#| fig-width: 1.5
#| fig-height: 0.5
p1
```

But you can change the way these numbers are interpreted using `default.units = "snpc"`. _Square_ NPCs let us use the shorter side of the device for both height and width, so we'll get the same angles regardless of how wide or tall something is.

```{r}
angled_gradient_square <- linearGradient(
  c("red", "orange"),
  x1 = 0, y1 = 0, x2 = 1, y2 = 1,
  default.units = "snpc")

p2 <- ggplot() +
  geom_blank() +
  theme(
    plot.background = element_rect(
      fill = angled_gradient_square),
    panel.background = element_blank())
```

```{r}
#| echo: fenced
#| fig-width: 0.5
#| fig-height: 1.5
p2
```

```{r}
#| echo: fenced
#| fig-width: 1.5
#| fig-height: 0.5
p2
```

:::{.column-margin}
You can also set `default.units` to a physical or other unit, like `"cm"` or `"char"`. Check out `?unit` for all the options.

\

You can also supply a full `unit()` to these parameters! I find `snpc` and the default `npc` to be the most useful for gradients, but there are cases where you'll want physical units—especially when we start making repeating patterns.

\
:::

## Sizing and positioning radial gradients

Radial gradients work in a similar way, but now we have a lot more parameters: `cx1`, `cy1`, `cx2` _and_ `cy2` for the centre points of the gradient, plus `r1` and `r2` for the radius of the start and end radii.

For most applications, you'll want `cx2` and `cy2` to be the same as `cx1` and `cy1`. Then imagine two concentric circles around that point, with radii `r1` and `r2`. These are the things of your gradient.

In fact, let's draw the circles on explicitly to help us visualise:


```{r}
library(ggforce)

my_ring <- radialGradient(
  c("red", "orange"),
  cx1 = 0.35, cy1 = 0.5, cx2 = 0.35, cy2 = 0.5,
  r1 = 0, r2 = 0.3,
  default.units = "snpc")
```

```{r}
#| echo: false
ggplot() +
  geom_point(aes(x = 0.35, y = 0.5), size = 4) +
  geom_circle(aes(x0 = 0.35, y0 = 0.5, r = 0.3),
    linetype = "dotted") +
  coord_equal() +
  theme_void() +
  scale_x_continuous(limits = c(0, 1),
    expand = expansion(0)) +
  scale_y_continuous(limits = c(0, 1),
    expand = expansion(0)) +
  theme(
    plot.background = element_rect(
      fill = my_ring),
    panel.background = element_blank())
```

If you omit `cx2` and `cy2` entirely, they'll default to the centre. So if you're setting `cx1` and `cy1`, set `cx2` and `cy2` too, even if it feels redundant!

:::{.callout-important collapse="true"}

## What happens if I place `cx1` and `cx2` someplace else?

\

Generally you'll want `cx2` and `cy2` to match `cx1` and `cy1`. But if you vary them, you can make asymmetric gradients, like this firework (or fireball?) effect:

```{r}
my_ring_assym <- radialGradient(
  c("red", "yellow"),
  cx1 = 0.4, cy1 = 0.5,
  cx2 = 0.65, cy2 = 0.5,
  r1 = 0.05, r2 = 0.26,
  default.units = "snpc")
```

```{r}
#| echo: false
ggplot() +
  geom_point(aes(x = 0.4, y = 0.5)) +
  geom_circle(aes(x0 = 0.4, y0 = 0.5, r = 0.05)) +
  geom_circle(aes(x0 = 0.65, y0 = 0.5, r = 0.26),
    linetype = "dotted") +
  scale_x_continuous(limits = c(0, 1),
    expand = expansion(0)) +
  scale_y_continuous(limits = c(0, 1),
    expand = expansion(0)) +
  coord_equal() +
  theme_void() +
  theme(
    plot.background = element_rect(fill = my_ring_assym))
```

The key to this is continuing to imagine those circles drawn around the two points. Before they were concentric, but now they have room to move.

If the centre of the first circle escapes (or grazes) the edge of the second circle, you get weirder effects:

```{r}
my_ring_broken <- radialGradient(
  c("red", "yellow"),
  cx1 = 0.5, cy1 = 0.5,
  cx2 = 0.7, cy2 = 0.5,
  r1 = 0.1, r2 = 0.15,
  default.units = "snpc")
```

```{r}
#| echo: false
ggplot() +
  geom_point(aes(x = 0.5, y = 0.5)) +
  geom_circle(aes(x0 = 0.5, y0 = 0.5, r = 0.1)) +
  geom_circle(aes(x0 = 0.7, y0 = 0.5, r = 0.15),
    linetype = "dotted") +
  scale_x_continuous(limits = c(0, 1),
    expand = expansion(0)) +
  scale_y_continuous(limits = c(0, 1),
    expand = expansion(0)) +
  coord_equal() +
  theme_void() +
  theme(
    plot.background = element_rect(fill = my_ring_broken))
```

:::

# Stacking gradients

But, as web developers know, we can make some powerful effects by stacking gradients on top of each other. And the third tool we have `pattern()`, lets us do exactly that.

As @coolbutuseless [notes](https://coolbutuseless.github.io/2021/07/01/r-v4.1.0-grid-graphics-new-feature-patterns/), `pattern()` can turn any other `<abbr>grob</abbr>`{=html} (graphical object) into a repeating pattern. That grob could be a shape that is in turn filled with a pattern or gradient. Or it could be a list of shapes filled with gradients!

So here's a helper function to help us "stack" gradients. It does two things.

The first is to wrap each pattern in a rectangle grob. Thankfully, the default sizing works well for overlaying gradients. We can just do `rectGrob(gp = gpar(fill = my_gradient)`.

The second is to stack our new rectangles and make them into a pattern. We'll use `grobTree()` to hold the list of rectangles before passing them to `pattern()`.

We'll also throw in some error checking to make sure that the arguments we're passing are actually patterns. But since we'll likely want to include at least one solid colour as well to serve as a background, let's keep those as well.

:::{.column-margin}
Valid colours are either those named in `colours()` or 6- or 8-digit [hex numbers](https://en.wikipedia.org/wiki/Web_colors#Hex_triplet) prefixed with a hashtag.
:::

```{r}
stack_patterns <- function(...) {
  patterns <- list(...)

  # helper function to check for solid colours
  is_valid_colour <- function(x) {
    is(x, "character") &&
      (x %in% colours() ||
        grepl("^\\#[0-9a-fA-F]{6}$", x) ||
        grepl("^\\#[0-9a-fA-F]{8}$", x))
  }

  # check if any are not a pattern or colour
  stopifnot(
    "All supplied arguments must be patterns" =
      patterns |>
        sapply(\(x) is(x, "GridPattern") ||
          is_valid_colour(x)) |>
        all()
  )

  # wrap each gradient in a grob
  patterns |>
    lapply(\(x) grid::rectGrob(gp = grid::gpar(fill = x))) ->
  pattern_grobs

  # return as a compound pattern
  grid::pattern(
    do.call(grid::grobTree, pattern_grobs),
    extend = "none")
}
```

We can use this directly as the `fill` for a theme element or geom in ggplot2. But what can we do with this power?

There are lots of great tools for building mesh gradients out of radial ones available for web developers, like [this one on Colorffy](https://colorffy.com/mesh-gradient-generator).

Although CSS gradients aren't specified exactly the same way as R's gradients, you can convert them pretty quickly. For example, here's the CSS code for [a more muted gradient](https://colorffy.com/mesh-gradient-generator?colors=2e4955-2e3655-3a2e55-553a2e):

:::{.column-margin}
On Colorffy, use the `<>` button to display the CSS code for the gradient.
:::

```{.css filename="CSS"}
background:
  radial-gradient(at 77% 92%, #2e4955 0px, transparent 50%),
  radial-gradient(at 36% 89%, #2e3655 0px, transparent 50%),
  radial-gradient(at 88% 67%, #3a2e55 0px, transparent 50%),
  radial-gradient(at 2% 12%, #553a2e 0px, transparent 50%) #000000;
```

Using R's tools and our new helper this would be:

```{r}
dark_gradient_bg <- stack_patterns(
  "black",
  grid::radialGradient(c("#2e4955ff", "#2e495500"),
    cx1 = 0.77, cy1 = 0.08, r1 = 0,
    cx2 = 0.77, cy2 = 0.08, r2 = 0.5),
  grid::radialGradient(c("#2e3655ff", "#2e365500"),
    cx1 = 0.36, cy1 = 0.11, r1 = 0,
    cx2 = 0.36, cy2 = 0.11, r2 = 0.5),
  grid::radialGradient(c("#3a2e55ff", "#3a2e5500"),
    cx1 = 0.88, cy1 = 0.33, r1 = 0,
    cx2 = 0.88, cy2 = 0.33, r2 = 0.5),
  grid::radialGradient(c("#553a2eff", "#553a2e00"),
    cx1 = 0.02, cy1 = 0.88, r1 = 0,
    cx2 = 0.02, cy2 = 0.88, r2 = 0.5))
```

:::{.callout-tip collapse="true"}

## Wait, walk me through those gradients a little more

In CSS, you start each `radial-gradient()` with coordinates for the centre of the gradient. In R, this becomes the `cx1` and `cy1` arguments. Repeat them for `cx2` and `cy2`.

The y-coordinates in `{grid}` are flipped from the web (ie. top becomes bottom), so you'll want to subtract 1: 70% becomes 0.3, not 0.7!

The CSS gradients also specify second and further colours at "stops": rings going out from the centre point. In this case, they're all transparent at 50%.

We don't have `"transparent"` here. Instead, I'll repeat the original colour but make it transparent by adding zero opacity (`00`) to the end of it.
:::

Once we have our stack of gradients, we can use the gradient pattern as a plot background or just about anything else in `{ggplot2}`. Here's a full example using one as a plot background:


```{r}
ggplot(mtcars) +
  aes(mpg, hp) +
  geom_point(colour = "white") +
  theme_dark(base_size = 18, base_family = "Inter") +
  labs(title = "Gradient test") +
  theme(
    text = element_text(colour = "white"),
    plot.title = element_text(face = "bold"),
    panel.background = element_blank(),
    plot.background =
      element_rect(fill = dark_gradient_bg))
```




This technique is powerful, but it definitely be used poorly! For statistical plots, you'll likely want to keep backgrounds super muted — brighter colours are probably more appropriate for simpler graphics and headlines.