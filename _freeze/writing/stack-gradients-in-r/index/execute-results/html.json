{
  "hash": "ba1eed50146e5b5ddba8d5d4b305812a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: The guide to gradients in R and ggplot2\ncategories: [tutorial, rstats]\ndate: 2025-02-24\ndescription: Everything from the basics up to beautiful mesh gradients\nimage: stack-gradients-in-r.png\nresources:\n  - stack-gradients-in-r.png\n# title-block-banner: true   # manually styled\ntoc: true\nknitr:\n  opts_chunk:\n    fig-width: 8\n    dev: ragg_png\n    dev.args:\n      bg: transparent\n    \n---\n\nWe can do a lot of fancy stuff in [ggplot2](https://ggplot2.tidyverse.org) with considered use of fonts, sizes and colours. But there are still likely finishing touches that have us reaching for tools like Illustrator every so often.\n\nUntil recently, sophisticated gradient effects were one of those things. I often blur photos or use other similar patterns as slide backgrounds to provide a bit (a _bit!_) of visual interest.\n\nBut now, it's not hard to do something like that directly in ggplot2!\n\n{{< contents complete-example >}}\n\nGradients and patterns are looking reasonably mature now in R: they've been around [since R 4.1](https://stat.ethz.ch/pipermail/r-announce/2021/000670.html) (released in 2021), and ggplot2 began supporting them in version 3.5.0 (released in early 2024).\n\nThat support comes via the `{grid}` package, which ships with R but isn't preloaded. That means you'll either need to call `library(grid)` or prefix a lot of functions with `grid::`.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(grid)\nlibrary(systemfonts)\nlibrary(tibble)\nlibrary(lubridate)\nset.seed(1)\n```\n:::\n\n:::{#complete-example}\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Complete gradient example\"}\ntibble(\n  day = as.Date(\"2024-01-01\") + days(0:14),\n  count = runif(15, -10, 10),\n  sign = ifelse(count < 0, \"negative\", \"positive\")) |>\n  ggplot() +\n    aes(day, count, fill = sign) +\n    geom_col() +\n    guides(fill = \"none\") +\n    scale_fill_manual(values = list(\n      \"positive\" = linearGradient(\n        c(\"#d39417\", \"#e5260d\"),\n        stops = c(0.2, 1),\n        x1 = 0.5, y1 = 0, x2 = 0.5, y2 = 1),\n      \"negative\" = linearGradient(\n        c(\"#0854ce\", \"#4cb8ce\"),\n        stops = c(0.2, 1),\n        x1 = 0.5, y1 = 0, x2 = 0.5, y2 = 1)\n    )) +\n    theme_dark(base_size = 18, base_family = \"Inter\") +\n    theme(\n      text = element_text(colour = \"white\"),\n      axis.text = element_text(colour = \"#dddddd\"),\n      panel.background = element_blank(),\n      plot.background = element_blank(),\n      plot.title = element_text(face = \"bold\"),\n      panel.grid.major.x = element_blank(),\n      panel.grid.minor.x = element_blank(),\n    ) +\n    labs(\n      x = NULL, y = NULL,\n      title = \"Early January\",\n      subtitle = \"Daily scores compared to average\"\n    )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){fig-alt='A complete example of using gradients in ggplot2. The bars are filled using gradients mapped to a data column.' width=768}\n:::\n:::\n\n:::\n\nI'm also going to define a quick theme to keep these plots looking tidy. It's not really relevant to the post, though, so you can skip it if you'd like!\n\n:::{.callout-note collapse=\"true\"}\n\n## Plot theme\n\n::: {.cell}\n\n```{.r .cell-code}\ntheme_blog <- function() {\n  theme_dark(base_size = 18, base_family = \"Inter\") +\n  theme(\n    text = element_text(colour = \"white\"),\n    axis.text = element_text(colour = \"#dddddd\"),\n    panel.background = element_blank(),\n    plot.background = element_blank()\n  )\n}\n```\n:::\n\n:::\n\n:::{.column-margin}\nSome legacy R graphics devices don't support gradients and patterns at all. Install the [`{ragg}`](https://ragg.r-lib.org) package, which does — it's better for just about everything anyway!\n\n\\\n\nI also refer to the [`{systemfonts}`](https://systemfonts.r-lib.org) package above. This is an optional one to make using fonts on your system—or ones you've downloaded—easier.\n\n\\\n:::\n\n\nWe get two basic gradient tools in `{grid}`: `linearGradient()` and `radialGradient()`. If you've used apps like Photoshop or Illustrator before, that might seem basic — it's no [mesh gradient](https://helpx.adobe.com/au/illustrator/using/meshes.html).\n\nBut even this gives us a lot of power. With this new support, you can use a gradient or pattern as a static `fill` for a layer or theme element, or even as an aesthetic in some cases. (You can't, as far as I'm aware, use one as the outer `colour`.)\n\nSo that might be a geom's fill:\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(mtcars) +\n  aes(x = hp) +\n  geom_histogram(\n    bins = 30,\n    colour = \"transparent\",\n    fill = linearGradient(c(\"red\", \"orange\"))) +\n  theme_blog()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){fig-alt='Applying a a single gradient to the fill of a barchart.' width=768}\n:::\n:::\n\nOr it could be a theme option:\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(mtcars) +\n  aes(x = hp) +\n  geom_histogram(\n    bins = 30,\n    colour = \"transparent\") +\n  labs(title = \"Gradient as plot background\") +\n  theme_blog() +\n  theme(\n    plot.background = element_rect(\n      colour = NA,\n      fill = radialGradient(c(\"gold\", \"orange\", \"transparent\")))\n  )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){fig-alt='Applying a gradient to the background of a plot as a theme element.' width=768}\n:::\n:::\n\n\nYou're probably already realising that with this power comes the potential to make a lot of _ugly charts_—or, perhaps worse, unengaging or misleading ones!\n\n:::{.column-margin}\n\nWe'll be looking at a lot of gradients in this post. Let's turn this example into a function we can re-use:\n\n::: {.cell}\n\n```{.r .cell-code}\npreview_gradient <- \\(p) {\n  ggplot() +\n    geom_blank() +\n    theme(\n      plot.background =\n        element_rect(\n        fill = p),\n      panel.background =\n        element_blank())\n}\n```\n:::\n\n:::\n\nAll of the rules that apply to the accessible use of colour in data visualisation apply to gradients and patterns as well. Ensure that plot elements have sufficient contrast to be distinguished, particularly if the meaning of the plot is lost without it.\n\nBut with some care, we can add sophisticated effects using these tools.\n\n# Gradient basics\n\nThe most basic part of `linearGradient()` and `radialGradient()` is specifying the colours they use. Supply a vector of `colours` the same way you would supply colours elsewhere in R.\n\nIf you don't want those colours to be distributed evenly along the gradient, supply a vector of `stops` between 0 and 1. Here we squash the first half of the rainbow, spreading the second half out\n\n::: {.cell}\n\n```{.r .cell-code}\nsquashed_rainbow <- linearGradient(\n  c(\"red\", \"orange\", \"yellow\", \"green\", \"blue\", \"darkblue\", \"purple\"),\n  c(0, 0.1, 0.2, 0.4, 0.6, 0.8, 1)\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npreview_gradient(squashed_rainbow)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){fig-alt='A rainbow gradient—but the first three colours have shorter stops, while the other four have longer ones.' width=768}\n:::\n:::\n\n## Sizing and positioning linear gradients\n\nBy default, the two gradients take up the space of all of their parent: `linearGradient()` goes left-to-right and `radialGradient()` goes from the centre out to the (shorter) edge.\n\nTo change that, use the positional arguments. For `linearGradient`, those are `x1` and `y1` for the start position, and `x2` and `y2` for the end position. For example, to \n\nIf you simply provide these as numbers, the gradient will interpret these in \"Normalised Parent Coordinates\", which basically means \"percentages of the thing I'm being put on\". 0 is the (horizontal or vertical) start of the thing you're painting, and 1 is the end.\n\nHere's a gradient that stretches from the bottom-left corner to the top-right:\n\n::: {.cell}\n\n```{.r .cell-code}\nangled_gradient <- linearGradient(\n  c(\"red\", \"orange\"),\n  x1 = 0, y1 = 0, x2 = 1, y2 = 1)\n```\n:::\n\nOne downside of this is that it makes getting a specific angle right difficult, because a wide object and a tall object have things that stretch differently:\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- ggplot() +\n  geom_blank() +\n  theme(\n    plot.background = element_rect(\n      fill = angled_gradient),\n    panel.background = element_blank())\n```\n:::\n\n:::{#fig-tall-1}\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| fig-width: 0.5\n#| fig-height: 1.5\n#| fig-alt: A tall gradient, going from bottom-left to top-right.\np1\n```\n````\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){fig-alt='A tall gradient, going from bottom-left to top-right.' width=48}\n:::\n:::\n\n\n:::\n\n:::{#fig-wide-1}\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| fig-width: 1.5\n#| fig-height: 0.5\n#| fig-alt: A wide gradient, going from bottom-left to top-right.\np1\n```\n````\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){fig-alt='A wide gradient, going from bottom-left to top-right.' width=144}\n:::\n:::\n\n\n:::\n\nBut you can change the way these numbers are interpreted using `default.units = \"snpc\"`. _Square_ NPCs let us use the shorter side of the device for both height and width, so we'll get the same angles regardless of how wide or tall something is.\n\n::: {.cell}\n\n```{.r .cell-code}\nangled_gradient_square <- linearGradient(\n  c(\"red\", \"orange\"),\n  x1 = 0, y1 = 0, x2 = 1, y2 = 1,\n  default.units = \"snpc\")\n\np2 <- ggplot() +\n  geom_blank() +\n  theme(\n    plot.background = element_rect(\n      fill = angled_gradient_square),\n    panel.background = element_blank())\n```\n:::\n\n:::{#fig-tall-2}\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| fig-width: 0.5\n#| fig-height: 1.5\n#| fig-alt: A tall gradient. The gradient maintains a 45 degree angle.\np2\n```\n````\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){fig-alt='A tall gradient. The gradient maintains a 45 degree angle.' width=48}\n:::\n:::\n\n\n:::\n\n:::{#fig-wide-2}\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n#| fig-width: 1.5\n#| fig-height: 0.5\n#| fig-alt: A wide gradient. The gradient maintains a 45 degree angle.\np2\n```\n````\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){fig-alt='A wide gradient. The gradient maintains a 45 degree angle.' width=144}\n:::\n:::\n\n\n:::\n\n:::{.column-margin}\nYou can also set `default.units` to a physical or other unit, like `\"cm\"` or `\"char\"`. Check out `?unit` for all the options. You can also supply a full `unit()` to these parameters if you want to mix units!\n\n\\\n\nI find `snpc` and the default `npc` to be the most useful for gradients, but there are cases where you'll want physical units—especially when we start making repeating patterns.\n\n\\\n:::\n\n## Sizing and positioning radial gradients\n\nRadial gradients work in a similar way, but now we have a lot more parameters: `cx1`, `cy1`, `cx2` _and_ `cy2` for the centre points of the gradient, plus `r1` and `r2` for the radius of the start and end radii.\n\nFor most applications, you'll want `cx2` and `cy2` to be the same as `cx1` and `cy1`. Then imagine two concentric circles around that point, with radii `r1` and `r2`. These rings are the start and end of your gradient.\n\nIn fact, let's draw the circles explicitly to help us visualise:\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggforce)\n\nmy_ring <- radialGradient(\n  c(\"red\", \"orange\"),\n  cx1 = 0.35, cy1 = 0.5, cx2 = 0.35, cy2 = 0.5,\n  r1 = 0, r2 = 0.3,\n  default.units = \"snpc\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"Extra code: plot `my_ring` with circles overlaid\"}\nggplot() +\n  geom_point(aes(x = 0.35, y = 0.5), size = 4) +\n  geom_circle(aes(x0 = 0.35, y0 = 0.5, r = 0.3),\n    linetype = \"dotted\") +\n  coord_equal() +\n  theme_void() +\n  scale_x_continuous(limits = c(0, 1),\n    expand = expansion(0)) +\n  scale_y_continuous(limits = c(0, 1),\n    expand = expansion(0)) +\n  theme(\n    plot.background = element_rect(\n      fill = my_ring),\n    panel.background = element_blank())\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=768}\n:::\n:::\n\nIf you omit `cx2` and `cy2` entirely, they'll default to the centre. So if you're setting `cx1` and `cy1`, set `cx2` and `cy2` too, even if it feels redundant!\n\n:::{.callout-important collapse=\"true\"}\n\n## What happens if I place `cx1` and `cx2` someplace else?\n\n\\\n\nGenerally you'll want `cx2` and `cy2` to match `cx1` and `cy1`. But if you vary them, you can make asymmetric gradients, like this spotlight effect:\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_ring_assym <- radialGradient(\n  c(\"red\", \"yellow\"),\n  cx1 = 0.4, cy1 = 0.5,\n  cx2 = 0.65, cy2 = 0.5,\n  r1 = 0.05, r2 = 0.26,\n  default.units = \"snpc\")\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-1.png){fig-alt='A \\'fireball\\' effect created by shifting the middle of the inner circle just inside the edge of the outer circle.' width=768}\n:::\n:::\n\nThe key to this is continuing to imagine those circles drawn around the two points. Before they were concentric, but now they have room to move.\n\nThe defaults for the second circle are `cx2 = 0.5`, `cy2 = 0.5` and `r2 = 0.5`, which traces out a circle touching the edges of the parent. If you think of positioning and sizing the first point as positioning the spotlight within that circle, that might help you build a mental model of what to expect.\n\nBut if the centre of the first circle escapes (or grazes) the edge of the second circle, you get weirder effects:\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_ring_broken <- radialGradient(\n  c(\"red\", \"yellow\"),\n  cx1 = 0.5, cy1 = 0.5,\n  cx2 = 0.7, cy2 = 0.5,\n  r1 = 0.1, r2 = 0.15,\n  default.units = \"snpc\")\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-21-1.png){fig-alt='This radial gradient displays unexpected results because the middle of the inner circle has escaped rthe outer circle.' width=768}\n:::\n:::\n\n:::\n\n## Grouping\n\nThere's one other important parameter for `linearGradient()` and `radialGradient()`.\n\nThe `group` parameter (available since R 4.2.0) controls whether a gradient applies to individual shapes or to a set of them. It's `TRUE` by default. The difference is pretty obvious in some cases:\n\n:::{#fig-grouping-points layout-ncol=2}\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(mtcars) +\n  aes(mpg, disp) +\n  geom_point(size = 7, shape = 21, stroke = 0,\n    fill = linearGradient(c(\"red\", \"yellow\"))) +\n  theme_blog()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-22-1.png){fig-alt='Points with a gradient fill. With grouping, the gradient stretches across all of the points.' width=768}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(mtcars) +\n  aes(mpg, disp) +\n  geom_point(size = 7, shape = 21, stroke = 0,\n    fill = linearGradient(c(\"red\", \"yellow\"), group = FALSE)) +\n  theme_blog()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-23-1.png){fig-alt='Points with a gradient fill. Without grouping, each point gets the whole gradient, from red through to yellow.' width=768}\n:::\n:::\n\n:::\n\nBut in others the difference might be subtler. Take this time series example:\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(\n  day = as.Date(\"2024-01-01\") + days(0:14),\n  count = runif(15, -10, 10),\n  sign = ifelse(count < 0, \"negative\", \"positive\")) ->\nday_counts\n\ntimeseries_base <- ggplot(day_counts) +\n  aes(day, count, fill = sign) +\n  geom_col() +\n  guides(fill = \"none\") +\n  theme_blog()\n```\n:::\n\nYes, we can use gradients for aesthetics! The way to do it is to use `scale_fill_manual()` and provide each gradient in a list.\n\n:::{.column-margin}\nIf you've used `scale_*_manual()` before, you probably given `values` a named _vector_ using `c()`.\n\n\\\n\nDon't do that here: you need a named `list()`.\n:::\n\n:::{#fig-grouping-bars layout-ncol=2}\n\n::: {.cell}\n\n```{.r .cell-code}\ntimeseries_base +\n  scale_fill_manual(values = list(\n    \"positive\" = linearGradient(\n      c(\"yellow\", \"red\"),\n      x1 = 0.5, y1 = 0, x2 = 0.5, y2 = 1),\n    \"negative\" = linearGradient(\n      c(\"blue\", \"lightblue\"),\n      x1 = 0.5, y1 = 0, x2 = 0.5, y2 = 1)\n  ))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-25-1.png){fig-alt='Time series with grouping. The colour deepens consistently in all bars as they move away from the horizontal axis, so taller bars finish in a deeper tone that short ones.' width=768}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntimeseries_base +\n  scale_fill_manual(values = list(\n    \"positive\" = linearGradient(\n      c(\"yellow\", \"red\"),\n      x1 = 0.5, y1 = 0, x2 = 0.5, y2 = 1,\n      group = FALSE),\n    \"negative\" = linearGradient(\n      c(\"blue\", \"lightblue\"),\n      x1 = 0.5, y1 = 0, x2 = 0.5, y2 = 1,\n      group = FALSE)\n  ))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-26-1.png){fig-alt='Time series without grouping. Each bar finishes in the same, deep colours regardless of its height.' width=768}\n:::\n:::\n\n:::\n\nWithout grouping, every bar gets to the intense red or blue at the end of the gradient. If you're using the change in colour to reinforce the Y axis, this could be misleading!\n\nReady to go even further with gradients?\n\n# More advanced: stacking gradients\n\nAs web and print designers know, we can make some powerful effects by stacking gradients on top of each other. And the third tool we now have in R, `pattern()`, lets us do exactly that.\n\nThe secret to `pattern()`'s power is that it's recursive. We can turn any graphical object (called a \"grob\") into a repeating pattern.\n\nThat grob could be a picture you've provided separately, it could be a shape... or it could be a list of shapes!\n\n@coolbutuseless [explored](https://coolbutuseless.github.io/2021/07/01/r-v4.1.0-grid-graphics-new-feature-patterns/) the possibilities of these recursive `pattern()`s a while back, but we can put them to good use with gradients too.\n\nSo here's a helper function to help us \"stack\" gradients. It does two things.\n\nThe first is to wrap each pattern in a rectangle grob, or `rectGrob()`. Rectangles can be sized and positioned with `x`, `y`, `width` and `height` parameters, but if we're stacking gradients on top of each other, we can leave them all at their defaults.\n\nThe second step is to do the stacking. We'll use `grobTree()` to hold our list of rectangles before passing them to `pattern()`.\n\nWe'll also throw in some error checking to make sure that the arguments we're passing are actually patterns. And since we'll likely want to include at least one solid colour as well to serve as a background, let's keep those as well.\n\n:::{.column-margin}\nIn R, valid colours are either those named in `colours()` or 6- or 8-digit [hex numbers](https://en.wikipedia.org/wiki/Web_colors#Hex_triplet) prefixed with a hashtag. Things like:\n\n\\\n\n- `\"red\"` or `#ff0000`\n- `#00ff00aa` is a semi-transparent green\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstack_patterns <- function(...) {\n  patterns <- list(...)\n\n  # helper function to check for solid colours\n  is_valid_colour <- function(x) {\n    is(x, \"character\") &&\n      (x %in% colours() ||\n        grepl(\"^\\\\#[0-9a-fA-F]{6}$\", x) ||\n        grepl(\"^\\\\#[0-9a-fA-F]{8}$\", x))\n  }\n\n  # check if any are not a pattern or colour\n  stopifnot(\n    \"All supplied arguments must be patterns\" =\n      patterns |>\n        sapply(\\(x) is(x, \"GridPattern\") ||\n          is_valid_colour(x)) |>\n        all()\n  )\n\n  # wrap each gradient in a grob\n  patterns |>\n    lapply(\\(x) grid::rectGrob(gp = grid::gpar(fill = x))) ->\n  pattern_grobs\n\n  # return as a compound pattern\n  grid::pattern(\n    do.call(grid::grobTree, pattern_grobs),\n    extend = \"none\")\n}\n```\n:::\n\nWe can use `stack_patterns()` anywhere we would've used a single gradient. But what sort of gradients should we stack?\n\nThere are lots of great tools for building pseudo-mesh gradients out of radial ones, like [this generator on Colorffy](https://colorffy.com/mesh-gradient-generator).\n\nAlthough CSS gradients aren't specified in exactly the same way as R's gradients, you can convert them pretty quickly. For example, here's the CSS code for a splashy mix of bright colours:\n\n:::{.column-margin}\nOn Colorffy, use the `<>` button to display the CSS code for the gradient.\n:::\n\n```{.css filename=\"CSS\"}\nbackground:\n  radial-gradient(at 87% 87%, #eb4775 0px, transparent 50%),\n  radial-gradient(at 6%  99%, #eb6b47 0px, transparent 50%),\n  radial-gradient(at 76% 4%,  #ebbd47 0px, transparent 50%),\n  radial-gradient(at 35% 44%, #47ebbd 0px, transparent 50%),\n  radial-gradient(at 86% 45%, #4775eb 0px, transparent 50%) #ffffff;\n```\n\nUsing R's tools and our new helper this would be:\n\n::: {.cell}\n\n```{.r .cell-code}\nstacked_gradient_bg <- stack_patterns(\n  \"#ffffff\",\n  radialGradient(c(\"#eb4775ff\", \"#eb477500\"),\n    cx1 = 0.87, cy1 = 0.13, r1 = 0,\n    cx2 = 0.87, cy2 = 0.13, r2 = 0.5),\n  radialGradient(c(\"#eb6b47ff\", \"#eb6b4700\"),\n    cx1 = 0.06, cy1 = 0.01, r1 = 0,\n    cx2 = 0.06, cy2 = 0.01, r2 = 0.5),\n  radialGradient(c(\"#ebbd47ff\", \"#ebbd4700\"),\n    cx1 = 0.76, cy1 = 0.96, r1 = 0,\n    cx2 = 0.76, cy2 = 0.96, r2 = 0.5),\n  radialGradient(c(\"#47ebbdff\", \"#47ebbd00\"),\n    cx1 = 0.35, cy1 = 0.56, r1 = 0,\n    cx2 = 0.35, cy2 = 0.56, r2 = 0.5),\n  radialGradient(c(\"#4775ebff\", \"#4775eb00\"),\n    cx1 = 0.86, cy1 = 0.55, r1 = 0,\n    cx2 = 0.86, cy2 = 0.55, r2 = 0.5))\n```\n:::\n\n:::{.callout-tip collapse=\"true\"}\n\n## Wait, walk me through those numbers a little more\n\nIn CSS, each radial gradient starts with its position, as `at X Y`. Those become our `cx1`, `cy1`, `cx2` and `cy2` arguments (remember that we repeat the values again for `cx2` and `cy2`).\n\nOne wrinkle is that the y-coordinates need to be flipped from the web (ie. top becomes bottom), so you'll want to subtract 1: 70% becomes 0.3, not 0.7!\n\nThe Colorffy generator ends each radial gradient at the 50% mark in transparency to get the splotchy look.\n\nWe don't have a `\"transparent\"` keyword here. Instead, I'll repeat the original colour but make it transparent by adding zero opacity (`00`) to the end of it. At the start they're fully opaque (`ff`).\n\n:::\n\nOnce we have our stack of gradients, we can use the gradient pattern as a plot background or just about anything else in `{ggplot2}`:\n\n::: {.cell}\n\n```{.r .cell-code}\npreview_gradient(stacked_gradient_bg)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-29-1.png){fig-alt='A series of radial gradients stacked on top of each other. Each gradient ends in transparency, allowing the other gradients to be visible.' width=768}\n:::\n:::\n\nOf course, if you're using this as a background for an actual plot, you might need to dial things back to make the content readable.\n\nOne easy way to do that is to just make all the colours semi-transparent:\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(mtcars) +\n  aes(mpg, hp) +\n  geom_point() +\n  theme_blog() +\n  theme(\n    text = element_text(colour = \"black\"),\n    axis.text = element_text(colour = \"#222222\"),\n    plot.title = element_text(face = \"bold\"),\n    panel.background = element_blank(),\n    plot.background = element_rect(fill =\n      stack_patterns(\n        \"#ffffff\",\n        radialGradient(c(\"#eb477566\", \"#eb477500\"),\n          cx1 = 0.87, cy1 = 0.13, r1 = 0,\n          cx2 = 0.87, cy2 = 0.13, r2 = 0.5),\n        radialGradient(c(\"#eb6b4766\", \"#eb6b4700\"),\n          cx1 = 0.06, cy1 = 0.01, r1 = 0,\n          cx2 = 0.06, cy2 = 0.01, r2 = 0.5),\n        radialGradient(c(\"#ebbd4766\", \"#ebbd4700\"),\n          cx1 = 0.76, cy1 = 0.96, r1 = 0,\n          cx2 = 0.76, cy2 = 0.96, r2 = 0.5),\n        radialGradient(c(\"#47ebbd66\", \"#47ebbd00\"),\n          cx1 = 0.35, cy1 = 0.56, r1 = 0,\n          cx2 = 0.35, cy2 = 0.56, r2 = 0.5),\n        radialGradient(c(\"#4775eb66\", \"#4775eb00\"),\n          cx1 = 0.86, cy1 = 0.55, r1 = 0,\n          cx2 = 0.86, cy2 = 0.55, r2 = 0.5))))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-30-1.png){fig-alt='A scatter plot with a stacked radial gradient background. The colours are semi-transparent, making them less bright when blended with a white background.' width=768}\n:::\n:::\n\nBut if your content is simple and clear, you might be able to get away with bolder colours:\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(\n  day_n = 1:15,\n  day = as.Date(\"2024-01-01\") + days(day_n - 1),\n  score = day_n + rnorm(15)) |> \n  ggplot() +\n    aes(day, score) +\n    geom_col(fill = \"#1d2841\") +\n    labs(\n      x = NULL, y = \"Score\",\n      title = \"Big things happening!\") +\n    theme_blog() +\n    theme(\n      text = element_text(colour = \"#1d2841\"),\n      axis.text = element_text(colour = \"#29385b\"),\n      plot.title = element_text(face = \"bold.italic\"),\n      axis.ticks.x = element_blank(),\n      panel.grid = element_line(colour = \"#1d284144\"),\n      panel.grid.major.x = element_blank(),\n      panel.grid.minor.x = element_blank(),\n      panel.background = element_blank(),\n      plot.background = element_rect(\n        fill = stacked_gradient_bg))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-31-1.png){fig-alt='A bar chart using the original stacked background. Because the bars and text are very bold, the background can also use brighter colours without affecting the legibility of the content.' width=768}\n:::\n:::\n\nOf course, you don't have to stack radial gradients that fall off to transparency. You can combine all sorts of radial gradients, linear gradients and even other patterns composed of basic shapes.\n\nIf you're looking for some pattern inspiration, @coolbutuseless's [series of posts](https://coolbutuseless.github.io/2021/07/01/r-v4.1.0-grid-graphics-new-feature-patterns/) on building patterns is a great place to start!\n\n# Your new gradient powers\n\nWe've covered a lot here! We looked at:\n\n- Creating linear and radial gradients of various colours and sizes\n- Using those gradients both as static plot elements and as aesthetics\n- Stacking gradients to create powerful visual effects\n\nReady to go out and add some colour to your plots?\n\n:::{.callout-note}\n\n## Interpolating through different colour spaces\n\nOne last tip if you're still here!\n\n[Gradient colour schemes in ggplot2](https://ggplot2.tidyverse.org/reference/scale_gradient.html) support the ability to interpolate colours through different colour spaces. [CSS does too.](https://developer.mozilla.org/en-US/blog/css-color-module-level-4/)\n\nUsing a different colour space can be really useful, especially if your gradient uses colours that are far apart. Notice the grey colour in the middle of this gradient:\n\n::: {.cell}\n\n```{.r .cell-code}\nlinearGradient(c(\"#81fee9\", \"#f66eff\")) |>\n  preview_gradient()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-32-1.png){fig-alt='A gradient from light blue to light pink through RGB. The middle of the gradient is muddied to grey.' width=768}\n:::\n:::\n\n[CSS Tricks explains](https://css-tricks.com/color-spaces-for-more-interesting-css-gradients/) what's happening here well.\n\nI haven't yet found any option for setting the colour space in which to create a `linearGradient()` or a `radialGradient()`, and I assume that doing so would require the graphics device to support it (my understanding is that the current ones all work in RGB).\n\nIf you know of such an option, let me know!\n\nIn the mean time, the best solution is to add some stops that are pre-computed in the interpolation space you want. CSS Tricks links to an [excellent app](https://non-boring-gradients.netlify.app) by Tom Quinonero that demonstrates the difference:\n\n::: {.cell}\n\n```{.r .cell-code}\nlinearGradient(c(\n  \"#81fee9\",\n  \"#7Cd0ff\",\n  \"#7888ff\",\n  \"#ad73ff\",\n  \"#f66eff\")) |>\n  preview_gradient()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-33-1.png){fig-alt='A gradient from light blue to light pink through RGB. Extra stops are added to simulate interpolating through the HSL space, making the middle indigo instead of grey.' width=768}\n:::\n:::\n\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}